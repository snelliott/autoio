"""
 Functions to read in the projected frequencies generated by ProjRot
"""

import numpy
import autoparse.pattern as app
import autoparse.find as apf
import autoread as ar
from phydat import phycon


def rpht_output(output_str):
    """ Parses ProjRot frequency output file strings for the
        projected vibrational frequencies, sorted in ascending order.

        Works for the output of both
            (1) rotation-translation projections and
            (2) rotation-translation/hindered-rotor projections.

        :param output_str: string of lines of ProjRot output file
        :type output_str: str
        :rtype: (list(float), list(float)
    """

    # Read the file and read in the non-zero frequencies
    freqs = []
    for line in output_str.splitlines():
        line = line.strip()
        if line != '':
            freqs.append(float(line))

    # Build lists for the real and imaginary frequencies
    real_freqs = []
    imag_freqs = []
    for freq in freqs:
        # Ignore zeros and grab the negative vals from projrot out_str
        if freq != 0.0:
            if freq > 0.0:
                real_freqs.append(freq)
            else:
                imag_freqs.append(-1.0*freq)

    # Sort imaginary freqeuncies in descending order
    imag_freqs.sort(reverse=True)

    return tuple(sorted(real_freqs)), tuple(sorted(imag_freqs))


def normal_coordinates(output_str):
    """ Parse the normal coordinates of the vibrational modes out
        of the ProjRot displacement output files: *_cd.dat

        Works for the output of both
            (1) rotation-translation projections and
            (2) rotation-translation/hindered-rotor projections.

        Since ProjRot outputs the displacements in Gaussian frequency
        format, this function is similar to the Gaussian parser.

        Currently, does NOT follow the order of the frequency reader.
        Need to fix.

        :param output_str: string of lines of ProjRot output file
        :type output_str: str
        :rtype: tuple(numpy.ndarray)
    """

    # Set the patterns to read the normal coordinates
    comp_ptt = app.UNSIGNED_INTEGER + app.SPACES + app.UNSIGNED_INTEGER

    # Gaussian prints freqs/norm coords as columns. Up to 3 columns printed
    # Three patterns used to handle cases of when 1, 2, or 3 columns printed
    start_ptt = 'Atom  AN      X      Y      Z'
    start_ptt2 = '        X      Y      Z'
    start_ptt_lst = (
        (start_ptt + start_ptt2 + start_ptt2),  # 3 freq column(s)
        (start_ptt + start_ptt2),               # 2 freq column(s)
        (start_ptt),                            # 1 freq column(s)
    )

    # Read the normal coordinate modes
    nmodes = ()
    for mode in apf.split('Frequencies', output_str)[1:]:
        mat = None
        # Parse out coords by trying all possibilities of nfreq cols printed
        for start in start_ptt_lst:
            _ptt = app.padded(app.NEWLINE).join([app.escape(start), ''])
            mat = ar.matrix.read(
                mode, start_ptt=_ptt, line_start_ptt=comp_ptt)
            if mat is not None:
                # If pattern found, slice 3xN mat into N 3x3 mats
                # where N/3 corresponds to number of freq columns parsed
                nmat = numpy.array(mat) * phycon.ANG2BOHR
                _, ncols = numpy.shape(nmat)
                for i in range(int(ncols/3)):
                    nmodes += (nmat[:, i*3:(i+1)*3],)
                break

    # Set nmodes to None if nothing found from apf.split command
    if not nmodes:
        nmodes = None

    return nmodes
